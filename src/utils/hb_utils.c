#include "hb_utils.h"

#include "hw_board.h"
#include "hw_gpio.h"
#include "hw_pwm.h"
#include "hb_display.h"
#include "hb_storage.h"
#include <assert.h>
#include "hb_build_config.h"
#include "esp_sleep.h"
#include "driver/rtc_io.h"
#include "hb_pwr_node.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

/*************************************************************************
*  Format conversion functions
*************************************************************************/

static uint8_t hex[] = "0123456789ABCDEF";

uint8_t hexchar2nibble (uint8_t c)
{
    return (c <= '9') ? (c - '0') : ((c | 0x20) - 'a' + 10);
}

uint8_t hex2byte_ (uint8_t* src_buf)
{
    return (hexchar2nibble(src_buf[0]) << 4) + hexchar2nibble(src_buf[1]);
}

void byte2hex (uint8_t byte, uint8_t* dst_buf)
{
    dst_buf[0] = hex[byte >> 4];
    dst_buf[1] = hex[byte & 0x0F];
}

void short2hex (uint8_t* src_buf, uint8_t* dst_buf)
{
    byte2hex(src_buf[0], &dst_buf[0]);
    byte2hex(src_buf[1], &dst_buf[2]);
}

void hex2short (uint8_t* src_buf, uint8_t* dst_buf)
{
    dst_buf[0] = hex2byte_(&src_buf[0]);
    dst_buf[1] = hex2byte_(&src_buf[2]);
}

void long2hex (uint8_t* src_buf, uint8_t* dst_buf)
{
    byte2hex(src_buf[0], &dst_buf[0]);
    byte2hex(src_buf[1], &dst_buf[2]);
    byte2hex(src_buf[2], &dst_buf[4]);
    byte2hex(src_buf[3], &dst_buf[6]);
}

void hex2long (uint8_t* src_buf, uint8_t* dst_buf)
{
    dst_buf[0] = hex2byte_(&src_buf[0]);
    dst_buf[1] = hex2byte_(&src_buf[2]);
    dst_buf[2] = hex2byte_(&src_buf[4]);
    dst_buf[3] = hex2byte_(&src_buf[6]);
}

void bin2hex (uint8_t* src_buf, uint8_t* dst_buf, uint32_t bin_data_len)
{
    uint32_t i;

    for (i = 0; i < bin_data_len; i++) {
        byte2hex(src_buf[i], &dst_buf[i * 2]);
    }
}

void hex2bin (uint8_t* src_buf, uint8_t* dst_buf, uint32_t hex_data_len)
{
    uint32_t i;

    for (i = 0; i < hex_data_len / 2; i++) {
        dst_buf[i] = hex2byte_(&src_buf[2 * i]);
    }
}

uint32_t is_hex_digit (uint8_t c)
{
    if (((c >= '0') && (c <= '9')) ||
        ((c >= 'A') && (c <= 'F')) ||
        ((c >= 'a') && (c <= 'f')))
    {
        return 1;
    }
    return 0;
}

void* int2ascii (int32_t i, void* dst_buf)
{
    char const digit[] = "0123456789";
    int shifter;
    char* p = dst_buf;

    if (i < 0)
    {
        *p++ = '-';
        i = -i;
    }

    shifter = i;

    do
    {
            // move to where representation ends
        ++p;
        shifter = shifter/10;
    } while (shifter);

    *p = '\0';

    do
    {
            // move back, inserting digits as u go
        *--p = digit[i % 10];
        i = i / 10;
    } while(i);

    return dst_buf;
}
/* =============================================================== */



/* ******************************************************************
 * CRC related functions
 * *****************************************************************/

uint16_t crc16_update(uint16_t crc, uint8_t data)
{
    int i;

    crc = crc ^ ((uint16_t)data << 8);

    for (i = 0; i < 8; i++)
    {
        if (crc & 0x8000) {
            crc = (crc << 1) ^ 0x8005;
        } else {
            crc <<= 1;
        }
    }

    return crc;
}

uint16_t crc16_update_bulk(uint16_t crc, uint8_t data[], int len)
{
    for (int i=0; i<len; i++) {
        crc = crc16_update(crc, data[i]);
    }
    return crc;
}

uint16_t crc16(const uint8_t* buf, uint32_t len)
{
    uint16_t res = 0;
    uint32_t i;

    for (i = 0; i < len; i++) {
        res = crc16_update(res, buf[i]);
    }
    return res;
}

uint16_t crc16_table(uint8_t *adr_buffer, uint32_t byte_cnt)
{
    static unsigned char auchCRCHi[]=
    {
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
        0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
    };
    /*Table of CRC values for low–order byte*/
    static char auchCRCLo[]=
    {
        0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
        0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
        0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
        0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
        0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
        0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
        0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
        0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
        0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
        0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
        0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
        0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
        0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
        0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
        0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
        0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40,
    };

    unsigned char uchCRCHi = 0xFF;
    unsigned char uchCRCLo = 0xFF;
    unsigned uIndex;

    /* CRC Generation Function */
    while( byte_cnt--) /* pass through message buffer */
    {
        uIndex = uchCRCHi ^ *adr_buffer++; /* calculate the CRC */
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
        uchCRCLo = auchCRCLo[uIndex];
    }
    return (uchCRCHi << 8 | uchCRCLo);
}

void crc32(uint32_t* _crc, const uint8_t* _data, uint32_t _len)
{
    static const uint32_t s_crc32_table[256] = {
        0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
        0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
        0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
        0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
        0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
        0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
        0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
        0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
        0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
        0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
        0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
        0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
        0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
        0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
        0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
        0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
        0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
        0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
        0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
        0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
        0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
        0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
        0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
        0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
        0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
        0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
        0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
        0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
        0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
        0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
        0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
        0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
        0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
        0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
        0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
        0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
        0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
        0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
        0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
        0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
        0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
        0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
        0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
        0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
        0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
        0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
        0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
        0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
        0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
        0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
        0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
        0x2d02ef8dL
    };

    assert(_crc);
    assert(_data);

#define CRC32_DO1(p) do { crc = s_crc32_table[(crc ^ (uint32_t)(*p++)) & 0xff] ^ (crc >> 8); } while (0)
#define CRC32_DO2(p) do { CRC32_DO1(p); CRC32_DO1(p); } while (0)
#define CRC32_DO4(p) do { CRC32_DO2(p); CRC32_DO2(p); } while (0)
#define CRC32_DO8(p) do { CRC32_DO4(p); CRC32_DO4(p); } while (0)

    uint32_t crc = *_crc;
    crc ^= 0xffffffffUL;

    while (_len >= 8)
    {
        CRC32_DO8(_data);
        _len -= 8;
    }

    if (_len)
        do
            CRC32_DO1(_data);
        while (--_len);
    *_crc = crc ^ 0xffffffffUL;

#undef CRC32_DO8
#undef CRC32_DO4
#undef CRC32_DO2
#undef CRC32_DO1
}
/* =============================================================== */
#ifdef HB_TRACE

char* addr2str(char* _addr)
{
  static char buf[32];
  const uint8_t *addr = (uint8_t*)_addr;
  sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", addr[5], addr[4], addr[3],
    addr[2], addr[1], addr[0]);
  return buf;
}

/* ******************************************************************
 * Print buffer functions
 * *****************************************************************/

void print_buf_hex(uint8_t* buf, uint32_t len, uint32_t add_new_line)
{
    uint32_t i;
    HBPRINT("print_buf(%lu): ", len);
    for (i = 0; i < len; i++) {
        //printf("%02X ", buf[i]);
        HBPRINT("%02X", (char)buf[i]);
    }

    if (add_new_line != 0) {
        HBPRINT("\r\n");
    }
}

void print_buf(uint8_t* buf, uint32_t len, uint32_t add_new_line)
{
    uint32_t i;

    for (i = 0; i < len; i++) {
        HBPRINT("%02X", buf[i]);
    }

    if (add_new_line != 0) {
        HBPRINT("\n\n");
    }
}

void print_vartype32(void* pval)
{
#if 0
    uint8_t* p_int = pval;
    uint32_t i;

    for (i = 0; i < 4; i++)
    {
		HBPRINT("%02X", p_int[3 - i]);
    }
#endif
}

void print_chars(uint8_t* buf, uint32_t len)
{
    uint32_t i;

    for (i = 0; i < len; i++) {
        HBPRINT("%c", buf[i]);
    }
    HBPRINT("\n");
}

void print_rx_buff(uint8_t* buf, uint32_t len)
{
    HBPRINT("    RX buffer [%2ld bytes]: ", len);
    print_chars(buf, len);
    HBPRINT("\n");
}

#endif // HB_TRACE
/* =============================================================== */

// standby mode
void system_standby()
{
	db_params.current_mode = 2;

	hw_pwm_value_set(0, 0); //125
	hw_pwm_deinit();
	dev_params.light = 0;

	// ====================================
	// == COMMAND SAM4 FOR STANDBY ENTER ==
	// ====================================

	//vTaskDelay(((MCU_SLEEP_TIME_US/1000) + 200) / portTICK_PERIOD_MS);

	esp_sleep_enable_touchpad_wakeup();
	esp_light_sleep_start();

	// ==================================
	// == WAKEUP SAM4 FOR STANDBY EXIT ==
	// ==================================

	db_params.current_mode = 0;
}

// power off
void system_shutdown()
{
	db_params.current_mode = 3;

	hw_pwm_value_set(0, 0); //125
	hw_pwm_deinit();
	dev_params.light = 0;

	// ===============================
	// == COMMAND SAM4 FOR SHUTDOWN ==
	// ===============================

	//vTaskDelay(((MCU_SLEEP_TIME_US/1000) + 200) / portTICK_PERIOD_MS);

	esp_sleep_enable_touchpad_wakeup();
	esp_light_sleep_start();

	db_params.current_mode = 0;
}
